# PYTHON 基础 ******************************************************************

--------------------------------------------------------------------------------
|              while 循环的 else                                                |
--------------------------------------------------------------------------------
|a = 0                                                                         |
|while a < 10:                                                                 |
|    print a                                                                   |
|    a += 1                                                                    |
|    if a > 5:                                                                 |
|        continue                                                              |
|    if a > 9:                                                                 |
|        break                                                                 |
|else:                                                                         |
|    print "ok."                                                               |
|                                                                              |
| while中的else这段代码 如果循环是正常结束 则执行else内的方法                          |
| 虽然中间遭遇了 continue 依然可以执行                                              |
| 但如果是break结束 则不执行                                                       |
--------------------------------------------------------------------------------

# 商和余数同时得到 divmod()

# from sys import getrefcount
# a = 1
# print getrefcount(a) # 获得该变量被引用的次数


# 定长列表 双端队列 ==================================================================
from collections import deque
deque(maxlen=10) 定长列表 数组 双端队列 maxlen 决定长度 自动挤出去之前下标为0的数据


# 键盘中断错误 KeyboardInterrupt ============================================================

# 剥离扩展名 from os.path import splitext

# from inspect import getcallargs 获得真实的参数

# python文件指针的问题 ========================================================================
with open("test.txt", "r+") as f:
        new_content = f.read().replace("{", "") # 读取替换
        f.seek(0,0) # 移动指针到头顶
        f.truncate() # 清除指针往后的内容 重点是这个方法只会清除指针往后的内容
        f.seek(0,0) # 移动指针到头顶
        f.write(new_content) # 写入新的内容
# ===========================================================================================
# try 的 else
try:
    1 + 2
except:
    print "错了"
else:
    print "对了"
finally:
    print "管你是错了还是对了"


# MYSQL ======================================================================
cur.execute() # 执行mysql
cur.fetchall() # 获得所有结果
cur.fetchmany() # 获得条数结果  [cur.arraysize 是默认值]
cur.fetchone() # 获得第一条
cur.lastrowid # 插入的上条记录的ID
cur._last_executed # 插入时生成的SQL语句
conn.cursor() # 开启一个游标 可以传入一个游标类 例如:DictCursor
conn.commit() # 提交
conn.get_autocommit() # 获得是否开启了自动提交
conn.rollback() # 回滚提交
conn.client_flag # 客户端编号
conn.connect_timeout # 连接超时时间
conn.connected_time # 当前连接时间
conn.cursorclass # 游标类
conn.db # 当前数据库名称
conn.encoding # 编码类型
conn.host_info/get_host_info() # 获得主机地址 端口号 socket 127.0.0.1:3306
conn.insert_id() # 上一个提交的ID
conn.host # 主机地址
conn.port # 主机端口
conn.ping() # 测试连接
conn.user # 数据库用户名
conn.password # 数据库密码
conn.server_status #服务器状态 1 正常
conn.server_thread_id # 本次连接被分配的线程ID
conn.ssl # 是否是SLL连接





# 选择KEY的 lambda ==================================================================
from operator import itemgetter

# 原来tornado的 yield  是为了注册回调函数,方便返回值,代码同步的作用
# 如果要全异步，真正的办法是不加yield 但是一定要启动一个tornado的io_loop
# python 命令行 参数方法


# 断点续传 http

# BeautifulSoup =====================================================================

递归深度 recursive=False  例如find("div") 只查找子级别 不查找孙级别及以下的

# 删除子dom
dom = """
<div class="crumbs">
    <a href="http://video.duowan.com">多玩视频</a>
    <i></i><a href="http://video.duowan.com/u/1434552658">虎牙视频</a>
    <i></i>
    提取字符串
</div>

"""
soup = BeautifulSoup(dom)
[s.extract() for s in soup(['a','i'])] # 都删除
soup.getText() ->提取字符串

# 汉字转拼音的库 xpinyin


# =======================================================================================

functools.total_ordering
复制代码 代码如下:

functools.total_ordering(cls)

这个装饰器是在python2.7的时候加上的，它是针对某个类如果定义了__lt__、le、gt、__ge__这些方法中的至少一个，使用该装饰器，则会自动的把其他几个比较函数也实现在该类中
复制代码 代码如下:

@total_ordering
class Student:
    def __eq__(self, other):
        return ((self.lastname.lower(), self.firstname.lower()) ==
                (other.lastname.lower(), other.firstname.lower()))
    def __lt__(self, other):
        return ((self.lastname.lower(), self.firstname.lower()) <
                (other.lastname.lower(), other.firstname.lower()))
print dir(Student)

得到
复制代码 代码如下:

['__doc__', '__eq__', '__ge__', '__gt__', '__le__', '__lt__', '__module__']